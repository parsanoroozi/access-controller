# Access Control and Token Best Practices

---

### 1Ô∏è‚É£ Token Generation

* Tokens should **only be generated at the `/token` endpoint**.
* Do **not** generate a new token for every API request.

---

### 2Ô∏è‚É£ Client Secret Handling

* Never send client secrets in the request body.
* Use **Authorization header** (Basic auth) for client authentication.
* Prefer sending **access token + resourceId** in requests instead of secrets.

---

### 3Ô∏è‚É£ Minimize DB Hits

* Put as much information as possible into the JWT to **avoid frequent DB lookups**.
* JWT claims allow stateless validation.

---

### 4Ô∏è‚É£ Extract Data from JWT

* Avoid sending **clientId, clientSecret, or username** in request body.
* Extract them from **JWT claims** instead.

---

### 5Ô∏è‚É£ Resource Checks

* Do not rely on resource name alone.
* Verify **full resource attributes** (id, name, action, url, type).
* Use JWT claims when possible, DB/cache fallback only if necessary.

---

### 6Ô∏è‚É£ Efficient DB Access

* Avoid loading entire collections and iterating in code.
* Use **repository queries** to let DB handle filtering and checks.
* Always handle **nulls** safely.

---

### 7Ô∏è‚É£ Standardized Response Payload

Use a structured decision model:

```json
{
  "decision": "Permit" | "Deny",
  "authenticated": true,
  "obligations": [
    { "type": "reauth", "reason": "token_expiring" }
  ],
  "advice": [
    { "message": "Use scope invoice.read" }
  ],
  "policyId": "rbac-resource-v3",
  "reason": "role lacks invoice:write"
}
8Ô∏è‚É£ Logging Practices
Avoid leaking sensitive signals.

Keep private information secure.

9Ô∏è‚É£ Client Types
Distinguish public vs confidential clients.

Do not issue refresh tokens to public clients for security.

üîë JWT Signing & Verification
Use RSA keys for signing JWTs.

Keep private key secure in IAM, expose public key at /jwks.

Signing process:

IAM generates JWT claims.

IAM signs JWT with private key.

Resource servers receive token.

Resource servers fetch IAM‚Äôs public key from /jwks.

Verify signature ‚Üí if valid, trust claims; if invalid, reject.

JWTs are Base64 encoded, not encrypted.

Clients can decode the JWT to read claims, which is expected.

JWT lifetime (5‚Äì15 min) ensures short-term security.

üîë Client Credentials
Both clientId and clientSecret are generated by IAM.

Think of them like username/password for the client.

clientId must be unique.

clientSecret is used only at /token to get access, refresh, or ID tokens.

‚ö° Token Content & Updates
Include as much info in JWT as possible to reduce DB hits.

Be precise about when to update tokens:

If resources, accounts, or client permissions change, invalidate old tokens.

Notify clients to fetch new tokens.

Suggested approach:

‚â§100 allowed resources ‚Üí embed full list in token (id, name, action, url, type, description).

100 allowed resources ‚Üí leave list empty, fallback to DB/cache for access checks.

üîë Key Management
One IAM key pair is sufficient.

No need to generate separate keys for each client.

‚úÖ Takeaways
JWT allows stateless access control.

Clients can independently check allowed resources via token claims.

Always combine JWT claims + DB/cache fallback for dynamic and large-scale resource access.