1) don't generate tokens for each request, tokens are generate within /token endpoint only

2) don't send client secrets in request body (keep it in header), remove the Client Secret from the payload, and authenticate the client in header using access tokens and...
maybe it's just better to send accessToken and the resourceId in the request...

3) when you check things with your token you can skip checking somethings with db. so put the more you can on JWT and less database hits

4) don't send ClientID, secret or username in the request body cause you can extract it from the claims of the access token

5) do not check the resource name alone, check the whole resource (in DB or from JWT)

6) if you are checking things from DB, don't get the collection and iterate and check things from the code, simple do the most of the biz of checking in the query, its way better and faster (Prefer repository queries over loading large collections) + handle null checks 

7) standardize your response payload: decision model:
 {
  "decision": "Permit" | "Deny",
  "authenticated": true,
  "obligations": [ { "type": "reauth", "reason": "token_expiring" } ],
  "advice": [ { "message": "Use scope invoice.read" } ],
  "policyId": "rbac-resource-v3",
  "reason": "role lacks invoice:write"
}

8) for Logging avoid leaking signals and keep more information of yours private.

9) Distinguish public vs confidential clients... no refresh tokens to public clients for security and safety

10) use RSA keys for signing the JWT's and let clients make sure its your IAM they are talking about, and keep your private key inside your project and expose your public key in /jwks endpoint so when you sign the JWT's with your private key, client can open it up with your public key and make sure its you and then use the JWT as they want...

(point: JWTs are encode with base64 and they are able to get decoded by clients if they want to get to the claims...) so its not necessary to keep JWTs encrypted and you can rely on their 5-15 minutes life time for security)

(point: ClientID and clientSecret are both generated by the IAM and they are like a username/password of the clients to your IAM, clientIDs should be unique and secrets are used on /token endpoint for when the clients needs to get access, refresh or even id tokens)

(point: the more you use your token to hold information so you can get rid of database hits, the more you need to be precise on the times you need to update your token, cause you may change a resource or an accounts or clients permission and you have to immediately change the access token accordingly and you have to alert the client to get a new token because the older token is no longer valid.)

(point: if accounts access list count was less than 100 you can put the list of the ids in the access token for quicker handling but if its more you should keep the resource list in the access token empty and check the database for each access control request)

(Point: its not necessary to have a private/public key for each client, just one to introduce you to other clients as you is enough)

how signing process works:
üõ†Ô∏è 4. So how does it work in your IAM?

IAM generates JWT claims.

IAM signs JWT with its private key.

Resource servers get the token.

They fetch IAM‚Äôs public key from /jwks.

They verify the signature with the public key.

If signature is valid ‚Üí they trust the claims.

If not ‚Üí reject the token.

........
giving JWT to clients make them independent to you for checking allowed resources of a user by opening up the JWT and get the claims of resource server...
(after authentication is the only time that even if the resource list of an account is more than 100 items you will send the whole list to them with not just the Id but also the name, action, url, type and the description)









